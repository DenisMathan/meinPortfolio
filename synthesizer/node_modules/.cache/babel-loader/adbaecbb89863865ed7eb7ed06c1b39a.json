{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * The unique id is used for unique hashes.\n */\n\nvar uniqueId = 0;\n/**\n * Tag styles with this string to get unique hashes.\n */\n\nexports.IS_UNIQUE = '__DO_NOT_DEDUPE_STYLE__';\nvar upperCasePattern = /[A-Z]/g;\nvar msPattern = /^ms-/;\nvar interpolatePattern = /&/g;\nvar escapePattern = /[ !#$%&()*+,./;<=>?@[\\]^`{|}~\"'\\\\]/g;\n\nvar propLower = function (m) {\n  return \"-\" + m.toLowerCase();\n};\n/**\n * CSS properties that are valid unit-less numbers.\n *\n * Ref: https://github.com/facebook/react/blob/master/packages/react-dom/src/shared/CSSProperty.js\n */\n\n\nvar CSS_NUMBER = {\n  'animation-iteration-count': true,\n  'border-image-outset': true,\n  'border-image-slice': true,\n  'border-image-width': true,\n  'box-flex': true,\n  'box-flex-group': true,\n  'box-ordinal-group': true,\n  'column-count': true,\n  'columns': true,\n  'counter-increment': true,\n  'counter-reset': true,\n  'flex': true,\n  'flex-grow': true,\n  'flex-positive': true,\n  'flex-shrink': true,\n  'flex-negative': true,\n  'flex-order': true,\n  'font-weight': true,\n  'grid-area': true,\n  'grid-column': true,\n  'grid-column-end': true,\n  'grid-column-span': true,\n  'grid-column-start': true,\n  'grid-row': true,\n  'grid-row-end': true,\n  'grid-row-span': true,\n  'grid-row-start': true,\n  'line-clamp': true,\n  'line-height': true,\n  'opacity': true,\n  'order': true,\n  'orphans': true,\n  'tab-size': true,\n  'widows': true,\n  'z-index': true,\n  'zoom': true,\n  // SVG properties.\n  'fill-opacity': true,\n  'flood-opacity': true,\n  'stop-opacity': true,\n  'stroke-dasharray': true,\n  'stroke-dashoffset': true,\n  'stroke-miterlimit': true,\n  'stroke-opacity': true,\n  'stroke-width': true\n}; // Add vendor prefixes to all unit-less properties.\n\nfor (var _i = 0, _a = Object.keys(CSS_NUMBER); _i < _a.length; _i++) {\n  var property = _a[_i];\n\n  for (var _b = 0, _c = ['-webkit-', '-ms-', '-moz-', '-o-', '']; _b < _c.length; _b++) {\n    var prefix = _c[_b];\n    CSS_NUMBER[prefix + property] = true;\n  }\n}\n/**\n * Escape a CSS class name.\n */\n\n\nexports.escape = function (str) {\n  return str.replace(escapePattern, '\\\\$&');\n};\n/**\n * Transform a JavaScript property into a CSS property.\n */\n\n\nfunction hyphenate(propertyName) {\n  return propertyName.replace(upperCasePattern, propLower).replace(msPattern, '-ms-'); // Internet Explorer vendor prefix.\n}\n\nexports.hyphenate = hyphenate;\n/**\n * Generate a hash value from a string.\n */\n\nfunction stringHash(str) {\n  var value = 5381;\n  var len = str.length;\n\n  while (len--) value = value * 33 ^ str.charCodeAt(len);\n\n  return (value >>> 0).toString(36);\n}\n\nexports.stringHash = stringHash;\n/**\n * Transform a style string to a CSS string.\n */\n\nfunction styleToString(key, value) {\n  if (typeof value === 'number' && value !== 0 && !CSS_NUMBER.hasOwnProperty(key)) {\n    return key + \":\" + value + \"px\";\n  }\n\n  return key + \":\" + value;\n}\n/**\n * Sort an array of tuples by first value.\n */\n\n\nfunction sortTuples(value) {\n  return value.sort(function (a, b) {\n    return a[0] > b[0] ? 1 : -1;\n  });\n}\n/**\n * Categorize user styles.\n */\n\n\nfunction parseStyles(styles, hasNestedStyles) {\n  var properties = [];\n  var nestedStyles = [];\n  var isUnique = false; // Sort keys before adding to styles.\n\n  for (var _i = 0, _a = Object.keys(styles); _i < _a.length; _i++) {\n    var key = _a[_i];\n    var value = styles[key];\n\n    if (value !== null && value !== undefined) {\n      if (key === exports.IS_UNIQUE) {\n        isUnique = true;\n      } else if (typeof value === 'object' && !Array.isArray(value)) {\n        nestedStyles.push([key.trim(), value]);\n      } else {\n        properties.push([hyphenate(key.trim()), value]);\n      }\n    }\n  }\n\n  return {\n    style: stringifyProperties(sortTuples(properties)),\n    nested: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),\n    isUnique: isUnique\n  };\n}\n/**\n * Stringify an array of property tuples.\n */\n\n\nfunction stringifyProperties(properties) {\n  return properties.map(function (_a) {\n    var name = _a[0],\n        value = _a[1];\n    if (!Array.isArray(value)) return styleToString(name, value);\n    return value.map(function (x) {\n      return styleToString(name, x);\n    }).join(';');\n  }).join(';');\n}\n/**\n * Interpolate CSS selectors.\n */\n\n\nfunction interpolate(selector, parent) {\n  if (selector.indexOf('&') === -1) return parent + \" \" + selector;\n  return selector.replace(interpolatePattern, parent);\n}\n/**\n * Recursive loop building styles with deferred selectors.\n */\n\n\nfunction stylize(selector, styles, rulesList, stylesList, parent) {\n  var _a = parseStyles(styles, selector !== ''),\n      style = _a.style,\n      nested = _a.nested,\n      isUnique = _a.isUnique;\n\n  var pid = style;\n\n  if (selector.charCodeAt(0) === 64\n  /* @ */\n  ) {\n      var child = {\n        selector: selector,\n        styles: [],\n        rules: [],\n        style: parent ? '' : style\n      };\n      rulesList.push(child); // Nested styles support (e.g. `.foo > @media > .bar`).\n\n      if (style && parent) child.styles.push({\n        selector: parent,\n        style: style,\n        isUnique: isUnique\n      });\n\n      for (var _i = 0, nested_1 = nested; _i < nested_1.length; _i++) {\n        var _b = nested_1[_i],\n            name = _b[0],\n            value = _b[1];\n        pid += name + stylize(name, value, child.rules, child.styles, parent);\n      }\n    } else {\n    var key = parent ? interpolate(selector, parent) : selector;\n    if (style) stylesList.push({\n      selector: key,\n      style: style,\n      isUnique: isUnique\n    });\n\n    for (var _c = 0, nested_2 = nested; _c < nested_2.length; _c++) {\n      var _d = nested_2[_c],\n          name = _d[0],\n          value = _d[1];\n      pid += name + stylize(name, value, rulesList, stylesList, key);\n    }\n  }\n\n  return pid;\n}\n/**\n * Transform `stylize` tree into style objects.\n */\n\n\nfunction composeStylize(cache, pid, rulesList, stylesList, className, isStyle) {\n  for (var _i = 0, stylesList_1 = stylesList; _i < stylesList_1.length; _i++) {\n    var _a = stylesList_1[_i],\n        selector = _a.selector,\n        style = _a.style,\n        isUnique = _a.isUnique;\n    var key = isStyle ? interpolate(selector, className) : selector;\n    var id = isUnique ? \"u\\0\" + (++uniqueId).toString(36) : \"s\\0\" + pid + \"\\0\" + style;\n    var item = new Style(style, id);\n    item.add(new Selector(key, \"k\\0\" + pid + \"\\0\" + key));\n    cache.add(item);\n  }\n\n  for (var _b = 0, rulesList_1 = rulesList; _b < rulesList_1.length; _b++) {\n    var _c = rulesList_1[_b],\n        selector = _c.selector,\n        style = _c.style,\n        rules = _c.rules,\n        styles = _c.styles;\n    var item = new Rule(selector, style, \"r\\0\" + pid + \"\\0\" + selector + \"\\0\" + style);\n    composeStylize(item, pid, rules, styles, className, isStyle);\n    cache.add(item);\n  }\n}\n/**\n * Cache to list to styles.\n */\n\n\nfunction join(arr) {\n  var res = '';\n\n  for (var i = 0; i < arr.length; i++) res += arr[i];\n\n  return res;\n}\n/**\n * Noop changes.\n */\n\n\nvar noopChanges = {\n  add: function () {\n    return undefined;\n  },\n  change: function () {\n    return undefined;\n  },\n  remove: function () {\n    return undefined;\n  }\n};\n/**\n * Implement a cache/event emitter.\n */\n\nvar Cache =\n/** @class */\nfunction () {\n  function Cache(changes) {\n    if (changes === void 0) {\n      changes = noopChanges;\n    }\n\n    this.changes = changes;\n    this.sheet = [];\n    this.changeId = 0;\n    this._keys = [];\n    this._children = Object.create(null);\n    this._counters = Object.create(null);\n  }\n\n  Cache.prototype.add = function (style) {\n    var count = this._counters[style.id] || 0;\n    var item = this._children[style.id] || style.clone();\n    this._counters[style.id] = count + 1;\n\n    if (count === 0) {\n      this._children[item.id] = item;\n\n      this._keys.push(item.id);\n\n      this.sheet.push(item.getStyles());\n      this.changeId++;\n      this.changes.add(item, this._keys.length - 1);\n    } else if (item instanceof Cache && style instanceof Cache) {\n      var curIndex = this._keys.indexOf(style.id);\n\n      var prevItemChangeId = item.changeId;\n      item.merge(style);\n\n      if (item.changeId !== prevItemChangeId) {\n        this.sheet.splice(curIndex, 1, item.getStyles());\n        this.changeId++;\n        this.changes.change(item, curIndex, curIndex);\n      }\n    }\n\n    return item;\n  };\n\n  Cache.prototype.remove = function (style) {\n    var count = this._counters[style.id];\n\n    if (count !== undefined && count > 0) {\n      this._counters[style.id] = count - 1;\n      var item = this._children[style.id];\n\n      var index = this._keys.indexOf(item.id);\n\n      if (count === 1) {\n        delete this._counters[style.id];\n        delete this._children[style.id];\n\n        this._keys.splice(index, 1);\n\n        this.sheet.splice(index, 1);\n        this.changeId++;\n        this.changes.remove(item, index);\n      } else if (item instanceof Cache && style instanceof Cache) {\n        var prevChangeId = item.changeId;\n        item.unmerge(style);\n\n        if (item.changeId !== prevChangeId) {\n          this.sheet.splice(index, 1, item.getStyles());\n          this.changeId++;\n          this.changes.change(item, index, index);\n        }\n      }\n    }\n  };\n\n  Cache.prototype.values = function () {\n    var _this = this;\n\n    return this._keys.map(function (key) {\n      return _this._children[key];\n    });\n  };\n\n  Cache.prototype.merge = function (cache) {\n    for (var _i = 0, _a = cache.values(); _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.add(item);\n    }\n\n    return this;\n  };\n\n  Cache.prototype.unmerge = function (cache) {\n    for (var _i = 0, _a = cache.values(); _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.remove(item);\n    }\n\n    return this;\n  };\n\n  Cache.prototype.clone = function () {\n    return new Cache().merge(this);\n  };\n\n  return Cache;\n}();\n\nexports.Cache = Cache;\n/**\n * Selector is a dumb class made to represent nested CSS selectors.\n */\n\nvar Selector =\n/** @class */\nfunction () {\n  function Selector(selector, id) {\n    this.selector = selector;\n    this.id = id;\n  }\n\n  Selector.prototype.getStyles = function () {\n    return this.selector;\n  };\n\n  Selector.prototype.clone = function () {\n    return new Selector(this.selector, this.id);\n  };\n\n  return Selector;\n}();\n\nexports.Selector = Selector;\n/**\n * The style container registers a style string with selectors.\n */\n\nvar Style =\n/** @class */\nfunction (_super) {\n  __extends(Style, _super);\n\n  function Style(style, id) {\n    var _this = _super.call(this) || this;\n\n    _this.style = style;\n    _this.id = id;\n    return _this;\n  }\n\n  Style.prototype.getStyles = function () {\n    return this.sheet.join(',') + \"{\" + this.style + \"}\";\n  };\n\n  Style.prototype.clone = function () {\n    return new Style(this.style, this.id).merge(this);\n  };\n\n  return Style;\n}(Cache);\n\nexports.Style = Style;\n/**\n * Implement rule logic for style output.\n */\n\nvar Rule =\n/** @class */\nfunction (_super) {\n  __extends(Rule, _super);\n\n  function Rule(rule, style, id) {\n    var _this = _super.call(this) || this;\n\n    _this.rule = rule;\n    _this.style = style;\n    _this.id = id;\n    return _this;\n  }\n\n  Rule.prototype.getStyles = function () {\n    return this.rule + \"{\" + this.style + join(this.sheet) + \"}\";\n  };\n\n  Rule.prototype.clone = function () {\n    return new Rule(this.rule, this.style, this.id).merge(this);\n  };\n\n  return Rule;\n}(Cache);\n\nexports.Rule = Rule;\n/**\n * The FreeStyle class implements the API for everything else.\n */\n\nvar FreeStyle =\n/** @class */\nfunction (_super) {\n  __extends(FreeStyle, _super);\n\n  function FreeStyle(hash, debug, id, changes) {\n    var _this = _super.call(this, changes) || this;\n\n    _this.hash = hash;\n    _this.debug = debug;\n    _this.id = id;\n    return _this;\n  }\n\n  FreeStyle.prototype.registerStyle = function (styles, displayName) {\n    var rulesList = [];\n    var stylesList = [];\n    var pid = stylize('&', styles, rulesList, stylesList);\n    var hash = \"f\" + this.hash(pid);\n    var id = this.debug && displayName ? displayName + \"_\" + hash : hash;\n    composeStylize(this, pid, rulesList, stylesList, \".\" + exports.escape(id), true);\n    return id;\n  };\n\n  FreeStyle.prototype.registerKeyframes = function (keyframes, displayName) {\n    return this.registerHashRule('@keyframes', keyframes, displayName);\n  };\n\n  FreeStyle.prototype.registerHashRule = function (prefix, styles, displayName) {\n    var rulesList = [];\n    var stylesList = [];\n    var pid = stylize('', styles, rulesList, stylesList);\n    var hash = \"f\" + this.hash(pid);\n    var id = this.debug && displayName ? displayName + \"_\" + hash : hash;\n    var rule = new Rule(prefix + \" \" + exports.escape(id), '', \"h\\0\" + pid + \"\\0\" + prefix);\n    composeStylize(rule, pid, rulesList, stylesList, '', false);\n    this.add(rule);\n    return id;\n  };\n\n  FreeStyle.prototype.registerRule = function (rule, styles) {\n    var rulesList = [];\n    var stylesList = [];\n    var pid = stylize(rule, styles, rulesList, stylesList);\n    composeStylize(this, pid, rulesList, stylesList, '', false);\n  };\n\n  FreeStyle.prototype.registerCss = function (styles) {\n    return this.registerRule('', styles);\n  };\n\n  FreeStyle.prototype.getStyles = function () {\n    return join(this.sheet);\n  };\n\n  FreeStyle.prototype.clone = function () {\n    return new FreeStyle(this.hash, this.debug, this.id, this.changes).merge(this);\n  };\n\n  return FreeStyle;\n}(Cache);\n\nexports.FreeStyle = FreeStyle;\n/**\n * Exports a simple function to create a new instance.\n */\n\nfunction create(hash, debug, changes) {\n  if (hash === void 0) {\n    hash = stringHash;\n  }\n\n  if (debug === void 0) {\n    debug = typeof process !== 'undefined' && process.env.NODE_ENV !== 'production';\n  }\n\n  if (changes === void 0) {\n    changes = noopChanges;\n  }\n\n  return new FreeStyle(hash, debug, \"f\" + (++uniqueId).toString(36), changes);\n}\n\nexports.create = create;","map":null,"metadata":{},"sourceType":"script"}